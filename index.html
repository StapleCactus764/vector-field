<!DOCTYPE html>
<!-- 
Vector Field
8/20/24

Click on the number at the top and type to change the number
of points simulated. Clicking inside the circle will pause.


About:
This uses Perlin noise to move points and tracks their paths.
It colors them based off of their position (top is bluer,
bottom is greener, and the right is redder).

I made this because, at the time I'm writing this, I'm working
on a game and a version of this will be the background. I noticed
while making the background that I could make it more colorful and
change some settings to make it bit better looking, which is how
we got this.


Credits:
Thank you to Stefan Gustavson for his code for 2D Perlin noise!
https://github.com/josephg/noisejs/blob/master/perlin.js


                 | Complicated Stuff |

Drawing:
This uses WebGL which makes the speed of drawing almost negligible (woo!).
Drawing is generally the main bottleneck for these types of
programs. Secondly, the tails store and update a lot less
information than the normal approach to these types of programs
would.


How the tails work:
The points' tails are made up of the recent past positions.
The most common way to make these types of tails is to store
something like 50 of the most recent positions and connect
them all. However, this ends up being very laggy! This program
only stores a total of 5 positions per tail.

So few positions would normally make the tails very short, but
the points only update their tails once every 10 frames, meaning
that they end up being a longer length. This presents yet another
issue, though. The points move very haltingly and look blocky, but
this issue is solved by interpolating between the current stored
position in the tail and the next stored position in the tail which
makes them look a lot smoother.

Using WebGL for the tails has another great advantage. It blends
colors between vertices together, so each segment of the tail
has a smooth gradient instead of being a solid color.

 -->
<html>
<head>
    <title>Vector Field</title>
    <meta charset="UTF-8">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Glegoo:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            overflow: hidden;
            translate: 0px 40px;
            margin: 0;
        }
        body * {
            position: absolute;
        }

        #wrapper {
            background-color: transparent;
            /*  */
            top: 10px;
            width: 200px;
            height: 25px;
            left: calc(50% - 100px);
            
            border-style: solid;
            border-color: rgb(240, 240, 240);
            border-radius: 50px;
        }
        #points-input {
            background-color: transparent;

            left: 20px;
            top: 3px;
            width: 170px;
            height: 17px;

            color: rgb(240, 240, 240);
            font-family: 'Glegoo', monospace;
            font-weight: 700;
            text-align: center;
            font-size: 1.2em;

            border-style: none;
            outline-style: none;
        }

        #field-canvas {
            filter: blur(0px);
        }
    </style>
</head>
    <body>
        <canvas id='field-canvas'></canvas>
        <canvas id='canvas'></canvas>

        <div id='wrapper'>
          <input id='points-input' type='number' value='8000'>
        </div>
        

        <script>
const tau = Math.PI * 2;
const lerp = (a, b, t) => a + (b - a) * t;

// https://github.com/josephg/noisejs/blob/master/perlin.js
// Full credit to Stefan Gustavson for this code!
(function(global){
    var module = global.noise = {};
  
    function Grad(x, y, z) {
      this.x = x; this.y = y; this.z = z;
    }
    
    Grad.prototype.dot2 = function(x, y) {
      return this.x*x + this.y*y;
    };
  
    Grad.prototype.dot3 = function(x, y, z) {
      return this.x*x + this.y*y + this.z*z;
    };
  
    var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];
  
    var p = [151,160,137,91,90,15,
    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
    // To remove the need for index wrapping, double the permutation table length
    var perm = new Array(512);
    var gradP = new Array(512);
  
    // This isn't a very good seeding function, but it works ok. It supports 2^16
    // different seed values. Write something better if you need more seeds.
    module.seed = function(seed) {
      if(seed > 0 && seed < 1) {
        // Scale the seed out
        seed *= 65536;
      }
  
      seed = Math.floor(seed);
      if(seed < 256) {
        seed |= seed << 8;
      }
  
      for(var i = 0; i < 256; i++) {
        var v;
        if (i & 1) {
          v = p[i] ^ (seed & 255);
        } else {
          v = p[i] ^ ((seed>>8) & 255);
        }
  
        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
      }
    };
  
    module.seed(0);
  
    /*
    for(var i=0; i<256; i++) {
      perm[i] = perm[i + 256] = p[i];
      gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
    }*/
  
    // Skewing and unskewing factors for 2, 3, and 4 dimensions
    var F2 = 0.5*(Math.sqrt(3)-1);
    var G2 = (3-Math.sqrt(3))/6;
  
    var F3 = 1/3;
    var G3 = 1/6;
  
    // 2D simplex noise
    module.simplex2 = function(xin, yin) {
      var n0, n1, n2; // Noise contributions from the three corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin+yin)*F2; // Hairy factor for 2D
      var i = Math.floor(xin+s);
      var j = Math.floor(yin+s);
      var t = (i+j)*G2;
      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
      var y0 = yin-j+t;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        i1=1; j1=0;
      } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        i1=0; j1=1;
      }
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1 + 2 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      i &= 255;
      j &= 255;
      var gi0 = gradP[i+perm[j]];
      var gi1 = gradP[i+i1+perm[j+j1]];
      var gi2 = gradP[i+1+perm[j+1]];
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0*x0-y0*y0;
      if(t0<0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1*x1-y1*y1;
      if(t1<0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
      }
      var t2 = 0.5 - x2*x2-y2*y2;
      if(t2<0) {
        n2 = 0;
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70 * (n0 + n1 + n2);
    };
  
    // 3D simplex noise
    module.simplex3 = function(xin, yin, zin) {
      var n0, n1, n2, n3; // Noise contributions from the four corners
  
      // Skew the input space to determine which simplex cell we're in
      var s = (xin+yin+zin)*F3; // Hairy factor for 2D
      var i = Math.floor(xin+s);
      var j = Math.floor(yin+s);
      var k = Math.floor(zin+s);
  
      var t = (i+j+k)*G3;
      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
      var y0 = yin-j+t;
      var z0 = zin-k+t;
  
      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if(x0 >= y0) {
        if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
        else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
        else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
      } else {
        if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
        else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
        else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
  
      var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
      var y2 = y0 - j2 + 2 * G3;
      var z2 = z0 - k2 + 2 * G3;
  
      var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
      var y3 = y0 - 1 + 3 * G3;
      var z3 = z0 - 1 + 3 * G3;
  
      // Work out the hashed gradient indices of the four simplex corners
      i &= 255;
      j &= 255;
      k &= 255;
      var gi0 = gradP[i+   perm[j+   perm[k   ]]];
      var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
      var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
      var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];
  
      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
      if(t0<0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
      if(t1<0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
      }
      var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
      if(t2<0) {
        n2 = 0;
      } else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
      }
      var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
      if(t3<0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 32 * (n0 + n1 + n2 + n3);
  
    };
  
    // ##### Perlin noise stuff
  
    function fade(t) {
      return t*t*t*(t*(t*6-15)+10);
    }
  
    function lerp(a, b, t) {
      return (1-t)*a + t*b;
    }
  
    // 2D Perlin Noise
    module.perlin2 = function(x, y) {
      // Find unit grid cell containing point
      var X = Math.floor(x), Y = Math.floor(y);
      // Get relative xy coordinates of point within that cell
      x = x - X; y = y - Y;
      // Wrap the integer cells at 255 (smaller integer period can be introduced here)
      X = X & 255; Y = Y & 255;
  
      // Calculate noise contributions from each of the four corners
      var n00 = gradP[X+perm[Y]].dot2(x, y);
      var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
      var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
      var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);
  
      // Compute the fade curve value for x
      var u = fade(x);
  
      // Interpolate the four results
      return lerp(
          lerp(n00, n10, u),
          lerp(n01, n11, u),
         fade(y));
    };
  
    // 3D Perlin Noise
    module.perlin3 = function(x, y, z) {
      // Find unit grid cell containing point
      var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
      // Get relative xyz coordinates of point within that cell
      x = x - X; y = y - Y; z = z - Z;
      // Wrap the integer cells at 255 (smaller integer period can be introduced here)
      X = X & 255; Y = Y & 255; Z = Z & 255;
  
      // Calculate noise contributions from each of the eight corners
      var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
      var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
      var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
      var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
      var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
      var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
      var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
      var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);
  
      // Compute the fade curve value for x, y, z
      var u = fade(x);
      var v = fade(y);
      var w = fade(z);
  
      // Interpolate
      return lerp(
          lerp(
            lerp(n000, n100, u),
            lerp(n001, n101, u), w),
          lerp(
            lerp(n010, n110, u),
            lerp(n011, n111, u), w),
         v);
    };
})(this);
        </script>
        <script>

const ctx = canvas.getContext('2d');

const col = {
    grayscale: {
        light: 'rgb(240, 240, 240)',
        dark: 'rgb(20, 20, 20)',

        lightArr: [240, 240, 240],
        darkArr: [20, 20, 20],
    },
};
let palette = col.grayscale;

let first = true;

const wrapper = document.getElementById('wrapper');
const input = document.getElementById('points-input');
input.addEventListener('change', e => {
    const num = +input.value;
    if (num < field.numPoints) {
        field.points.length = num;
    } else {
        for (let i = field.numPoints; i < num; i ++) {
            field.points[i] = new FieldPoint();
        }
    }
    field.numPoints = num;
});

let width, height;
const setup = () => {
    width = window.innerWidth;
    height = window.innerHeight;

    canvas.width = width;
    canvas.height = height;

    field.init();
    field.initgl();

    wrapper.style.top = (height / 2 - field.radius) / 2 - 40 + 'px';

    document.body.style.backgroundColor = palette.dark;

    first = false;
};



let frame = 0;

onresize = setup;

let clicked = false;
canvas.onmousedown = e => {
    if (Math.sqrt((e.offsetX - width / 2) ** 2 + (e.offsetY - height / 2) ** 2) < field.radius)
        clicked = !clicked;
};

const createShader = (gl, type, source) => {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
   
    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
};
const createProgram =(gl, vertexShader, fragmentShader) => {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
};
        </script>
        <script>
const vertexShader = `#version 300 es
in vec4 apos;
in vec3 aage;

out vec3 vage;
out vec2 vpos;

vec2 lerp(vec2 a, vec2 b, float t) {
    return a + (b - a) * t;
}

void main() {
    vage = aage;
    
    vec2 tpos = lerp(apos.xy, apos.zw, 1.0 - aage.z) * vec2(1, -1);
    vpos = tpos;

    gl_Position = vec4(tpos, 0, 1);
}`;

const fragmentShader = `#version 300 es
precision highp float;

in vec3 vage;
in vec2 vpos;
out vec4 outCol;

vec3 lerp(vec3 a, vec3 b, float t) {
    return a + (b - a) * t;
}

void main () {
    vec3 dark = vec3(20.0 / 255.0, 20.0 / 255.0, 20.0 / 255.0);
    vec3 light = vec3(0.2 + (vpos.x / 1.6 - 0.25) * 1.0, 0.4, 0.6 + (vpos.y / 2.0 - 0.1) * 1.0) / 1.0; //vec3(240.0 / 255.0, 240.0 / 255.0, 240.0 / 255.0);

    vec3 col = lerp(dark, light, pow(max(0.0, min(1.0 - vage.x / 3.0, vage.y) + 0.3), 2.0));
    outCol = vec4(col, 1);//vage / 10.0);
}`;

const field = {
    numPoints: 8000,
    points: [],
    time: 0,

    glReady: false,

    init() {
        this.width = width;
        this.height = height;

        this.radius = Math.min(width, height) * 0.8 / 2;
        
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        if (first) {
            for (let i = 0; i < this.numPoints; i ++) {
                this.points[i] = new FieldPoint();
            }
        }
    },
    initgl() {
        this.program = createProgram(
            this.gl,
            createShader(
                this.gl,
                this.gl.VERTEX_SHADER,
                vertexShader,
            ),
            createShader(
                this.gl,
                this.gl.FRAGMENT_SHADER,
                fragmentShader,
            ),
        );

        this.posAttrib = this.gl.getAttribLocation(this.program, 'apos');
        this.ageAttrib = this.gl.getAttribLocation(this.program, 'aage');
        this.camUniform = this.gl.getUniformLocation(this.program, 'cam');
        this.ptUniform = this.gl.getUniformLocation(this.program, 'pt');
        
        this.posBuffer = this.gl.createBuffer();
        this.ageBuffer = this.gl.createBuffer();

        this.positions = [];
        this.ages = [];
        // for (let i = 0; i < 20; i ++) {
        //     const nx = (Math.random() - 0.5) * 2, // * this.width,
        //         ny = (Math.random() - 0.5) * 2;// * this.height;
        //     this.positions.push(nx, ny, nx, ny);
        //     // this.positions.push((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2);
        // }
        // this.positions.pop();
        // this.positions.pop();

        

        // console.log(new Float32Array(this.positions));

        this.pvao = this.gl.createVertexArray();
        this.gl.bindVertexArray(this.pvao);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.positions), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.posAttrib);
        this.gl.vertexAttribPointer(this.posAttrib, 4, this.gl.FLOAT, false, 0, 0);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.ageBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.ages), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.ageAttrib);
        this.gl.vertexAttribPointer(this.ageAttrib, 3, this.gl.FLOAT, false, 0, 0);

        this.gl.viewport(0, 0, this.width, this.height);
    },
    fillBuffer() {
        this.positions.length = 0;
        this.ages.length = 0;
        
        /*
        Figure out how to do stuff with tail...
        Tail only updates every once-in-a-while
        Maybe sync everything? 
        Only update buffer when needed?
        
        Only update parts of buffer?
        Only one segment will change at a time,
        but that segment's location in the buffer
        will change as well.
        */

        for (const p of this.points) {
            if (p.tail.length > 2) {
                const pt = (frame + p.updateOffset) % FieldPoint.updateDelay / FieldPoint.updateDelay;

                this.positions.push(
                    p.x / this.width * 2,
                    p.y / this.height * 2,
                    p.x / this.width * 2,
                    p.y / this.height * 2,


                    p.tail[0] / this.width * 2,
                    p.tail[1] / this.height * 2,
                    p.tail[2] / this.width * 2,
                    p.tail[3] / this.height * 2,
                );

                // Age, transparency, pt
                this.ages.push(
                    0, p.trans, pt,
                    1, p.trans, pt,
                );

                for (let i = 0; i < p.tail.length - 6; i += 2) {
                    this.positions.push(
                        p.tail[i    ] / this.width * 2, // Current point
                        p.tail[i + 1] / this.height * 2,
                        p.tail[i + 2] / this.width * 2, // Lerp point
                        p.tail[i + 3] / this.height * 2,

                        p.tail[i + 2] / this.width * 2, // Next point
                        p.tail[i + 3] / this.height * 2,
                        p.tail[i + 4] / this.width * 2, // Lerp point
                        p.tail[i + 5] / this.height * 2,
                    );

                    // Age, transparency, pt
                    this.ages.push(
                        i / 2 + 1, p.trans, pt,
                        i / 2 + 2, p.trans, pt
                    );
                }
            }
        }

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.positions), this.gl.STATIC_DRAW);
        
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.ageBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.ages), this.gl.STATIC_DRAW);
    },

    canvas: document.getElementById('field-canvas'),
    gl: document.getElementById('field-canvas').getContext('webgl2'),

    runPoints() {
        if (clicked) return

        for (const point of this.points) point.update();

        this.time += 0.001;
    },
    displayBorder() {
        ctx.lineWidth = 7;
        ctx.strokeStyle = palette.light;
        ctx.beginPath();
        ctx.arc(width / 2, height / 2, this.radius, 0, tau);
        ctx.closePath();
        ctx.stroke();
    },
    
    rungl() {
        this.gl.clearColor(0, 0, 0, 0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);

        this.gl.useProgram(this.program);

        this.gl.bindVertexArray(this.pvao);

        // Each line has two verticies ( / 2) and each vertex takes 4 floats ( / 4)
        this.gl.drawArrays(this.gl.LINES, 0, this.positions.length / 4 / 2 * 2);
    },
};

class FieldPoint {
    static updateDelay = 10;
    static flag = true;
    constructor() {
        this.setPos();

        this.tailLen = 5;
        this.tail = [];

        this.updateOffset = Math.random() * FieldPoint.updateDelay | 0;

        this.cx = this.x + width / 2;
        this.cy = this.y + height / 2;
        this.speed = 1.5;
        this.scale = 1/300;

        this.lifespan = 10 + Math.random() * 10 | 0;
        this.life = this.lifespan ;
        this.age = 0;
        this.trans = 0;

        this.baby = true; // Juss a wittle babie (I don't know why I wrote that, haha)

        if (FieldPoint.flag) {
            FieldPoint.flag = false;
            this.flag = true;
        }     

        this.angle = (noise.perlin3(this.x * this.scale, this.y * this.scale, field.time)) * tau;
    }
    setPos() {
        const angle = Math.random() * tau;
        this.x = Math.cos(angle) * Math.random() * field.radius;
        this.y = Math.sin(angle) * Math.random() * field.radius;
        // this.x = (Math.random() - 0.5) * field.radius * 2;
        // this.y = (Math.random() - 0.5) * field.radius * 2;
    }
    respawn() {
        this.setPos();

        this.life = this.lifespan;
        this.age = 0;

        this.tail.length = 0;

        this.angle = (noise.perlin3(this.x * this.scale, this.y * this.scale, field.time)) * tau;
    }
    update() {
        let dx = Math.cos(this.angle) * this.speed,
            dy = Math.sin(this.angle) * this.speed;

        this.x += dx;
        this.y += dy;

        if ((frame + this.updateOffset) % FieldPoint.updateDelay === 0) {
            this.tail.unshift(this.x, this.y);
            if (this.tail.length > this.tailLen * 2) {
                this.tail.pop();
                this.tail.pop();
            }

            this.baby = this.tail.length !== this.tailLen * 2;

            if (!this.baby) {
                this.age ++;
                this.life --;
            }
        }

        this.trans = this.baby ? 0 : 1;
        if (!this.baby) {
            if (this.age < this.lifespan / 3) this.trans = (this.age - 1 + (frame + this.updateOffset) % FieldPoint.updateDelay / FieldPoint.updateDelay) * 3 / this.lifespan;
            if (this.life < this.lifespan / 3) this.trans = (this.life - (frame + this.updateOffset) % FieldPoint.updateDelay / FieldPoint.updateDelay) * 3 / this.lifespan;
        }

        this.angle = (noise.perlin3(this.x * this.scale, this.y * this.scale, field.time)) * tau;

        const dist = Math.sqrt(this.x ** 2 + this.y ** 2);

        if (this.life === 0 || dist > field.radius) this.respawn();
    }
}
        </script>

        <script>

setup();

field.init();
field.initgl();


const loop = () => {
    ctx.clearRect(0, 0, width, height);

    field.runPoints();
    field.fillBuffer();
    field.rungl();
    field.displayBorder();

    if (!clicked) frame ++;

    window.requestAnimationFrame(loop);
};
loop();

        </script>
    </body>
</html>
